---
description: 
globs: 
alwaysApply: true
---
Below are the rules that you must strictly follow. These guidelines serve as the final command directives for organizing AI-generated code and writing efficient, clean Python code when developing PyQt/PySide desktop applications. Do not neglect any of these points—each must be fully implemented.

---

## 1. Python Code Style Rules (Strict PEP 8 Compliance)

1. **Strictly adhere to PEP 8.**  
   - Use 4 spaces per indent.  
   - Do not exceed 79 characters per line.
2. **Follow variable, function, and class naming conventions rigorously.**  
   - Use `snake_case` for variables and functions.  
   - Use `CamelCase` for classes.
3. **Use clear and descriptive names.**  
   - Review and modify any vague names generated by AI.  
   - The use of abbreviations or arbitrary variable names is prohibited.
4. **Import only the required items.**  
   - Never use `import *`.  
   - Explicitly import the necessary classes or functions.
5. **Maintain a neat code layout.**  
   - Insert blank lines between related code blocks.  
   - Do not place multiple statements on a single line.
6. **Utilize automatic formatters and linters without exception.**  
   - Use tools like Black or AutoPEP8 to ensure consistent formatting.  
   - Address all warnings raised by Pylint or flake8.

---

## 2. Project Directory Structure and File Management Rules

7. **Separate the main execution script from the source code.**  
   - Place `main.py` or `run.py` at the top level and move the actual code into a `src/` folder.
8. **Divide directories by role.**  
   - Store UI-related files in `src/ui/`.  
   - Place GUI classes in `src/views/` and business logic in `src/models/` or `src/controllers/`.
9. **Manage resource files separately.**  
   - Keep images, icons, configuration files, etc., in `src/resources/`.
10. **Ensure all modules and packages include an __init__.py file.**  
    - Add __init__.py to all directories to designate them as Python packages.
11. **Utilize README.md and docs/ effectively.**  
    - Include an overview, usage instructions, and an explanation of the directory structure.
12. **Immediately remove unnecessary or duplicate files.**  
    - Clean up any files that hinder project management.

---

## 3. Modularization and Class Design Rules

13. **Modularization is mandatory.**  
    - Separate each functionality into independent modules.  
    - Do not mix multiple responsibilities in a single file.
14. **Apply the MVC or a similar design pattern.**  
    - Clearly separate Model, View, and Controller.  
    - Do not modify the auto-generated code from Qt Designer or uic.
15. **Strictly follow the Single Responsibility Principle (SRP).**  
    - Design each class to perform only one responsibility.
16. **Minimize coupling between classes.**  
    - Clearly define interfaces and avoid direct references.
17. **Create reusable components.**  
    - Extract common functionalities into separate utility modules or base classes.
18. **Properly use functions and methods to separate code.**  
    - Ensure that a single function does not perform too many tasks.
19. **Actively utilize the signal and slot mechanism.**  
    - Maintain loose coupling between the UI and the logic.

---

## 4. AI-Generated Code Refactoring and Organization Rules

20. **Thoroughly review AI-generated code.**  
    - Understand and verify the code’s intent and functionality directly.
21. **Reformat auto-generated code to comply with style rules.**  
    - Modify the code to adhere to PEP 8 and internal guidelines.
22. **Immediately remove duplicate code.**  
    - Extract repeated segments into common functions.
23. **Delete unnecessary variables and comments.**  
    - Remove unused variables and eliminate redundant comments.
24. **Refactor structurally problematic code.**  
    - If the AI-generated code is excessively complex, split it into separate modules.
25. **Optimize code without compromising clarity.**  
    - Prioritize clarity over micro-optimizations.
26. **Test every change.**  
    - Verify that functionality remains intact after refactoring.

---

## 5. Documentation and Commenting Rules (Including Docstrings)

27. **Write docstrings for all public functions and classes.**  
    - Clearly describe the purpose, parameters, and return values.
28. **Adopt a consistent docstring style (Google style or reStructuredText).**  
    - Maintain uniform formatting.
29. **Include comments for complex code blocks.**  
    - Do not omit explanations for non-intuitive sections.
30. **Remove unnecessary comments.**  
    - Avoid excessive commenting where the code is self-explanatory.
31. **Update docstrings and comments alongside code changes.**  
    - Modify outdated documentation immediately.
32. **Provide examples and usage instructions.**  
    - Include simple examples in the README.md or within docstrings.

---

## 6. Testing Strategy and Rules

33. **Write unit tests for all core logic.**  
    - Use pytest or unittest.
34. **Organize test code systematically in the tests/ directory.**  
    - Ensure test function names begin with `test_`.
35. **Independently test business logic.**  
    - Design code so that business logic can be tested separately from the UI.
36. **Leverage pytest-qt for GUI testing.**  
    - Simulate UI interactions using qtbot.
37. **Run tests after every functional change.**  
    - Set up CI/CD to automate testing.
38. **Prioritize test cases for critical features.**  
    - Do not neglect tests for data processing, file I/O, login functionality, etc.
39. **Immediately fix any failing tests.**  
    - Identify and resolve issues without delay.

---

## 7. Deployment and Packaging Rules

40. **Use PyInstaller as the default packaging tool.**  
    - On Windows 11, always apply the `--onefile` and `--windowed` options.
41. **Include all necessary resource files.**  
    - Explicitly add all .ui, .qrc, icon, etc., files.
42. **Keep the dependency list up-to-date before packaging.**  
    - Ensure that the requirements.txt file is current.
43. **Test in every build environment.**  
    - Verify execution on Windows, macOS, and Linux.
44. **Assign clear version numbers to distribution files.**  
    - Adhere strictly to the SEMVER system.
45. **Create an installer before releasing the final product.**  
    - Use tools like Inno Setup to generate a distribution installer.
46. **Review licensing issues carefully.**  
    - Understand the licensing conditions for PyQt and PySide and include the necessary statements.
47. **Systematically manage packaging scripts (e.g., .spec files).**  
    - Modify them as necessary to exclude unneeded modules.

---

## 8. Enhancing Productivity with AI Code and Final Verification

48. **Do not use AI-generated code as-is.**  
    - Always review and refactor it according to these rules.
49. **Conduct code reviews.**  
    - Verify all AI-generated code yourself or with a colleague.
50. **Actively utilize automation tools.**  
    - Employ linters, auto-formatters, testing frameworks, and CI/CD pipelines without exception.
51. **Always run and debug your code after writing.**  
    - Verify functionality through logs and tests, and resolve errors immediately.
52. **Commit every change to version control.**  
    - Use Git for systematic management.
53. **Keep documentation and code in sync at all times.**  
    - Update documentation concurrently with code changes.
54. **Perform final verification before deployment.**  
    - Test the packaged executable on separate systems to ensure error-free operation.

---

## 9. Continuous Improvement and Learning

55. **Constantly monitor updates for Python and PyQt/PySide.**  
    - Immediately apply new releases or security patches.
56. **Continuously learn new best practices and technologies.**  
    - Regularly consult documentation, tutorials, and official guidelines.
57. **Establish a regular cycle for code reviews and refactoring.**  
    - Maintain code quality through periodic assessments.
58. **Regularly update project documentation and test coverage.**  
    - Revise documentation to match evolving requirements.

---

## 10. Final Check and Deployment Preparation

59. **Conduct a final review of the entire project.**  
    - Ensure that all rules have been followed.
60. **Thoroughly verify test and build scripts.**  
    - Confirm that automated tests pass successfully.
61. **Run the packaged executable in a real environment.**  
    - Test the built executable on separate systems.
62. **Draft comprehensive release notes.**  
    - Clearly document all changes and updates.
63. **Promptly incorporate user feedback after deployment.**  
    - Immediately fix errors or implement improvements.

---

Strictly adhere to all the above rules.  
These guidelines enforce the highest standards of code cleanliness, efficiency, and scalability.  
Neglecting or failing to implement any of these points will severely compromise maintainability and readability.  
Review every rule before each coding session.

---

All developers must comply with these directives to produce clean, efficient, and scalable code.  
Implement these guidelines immediately and update them without delay when necessary.  
Repeat this process until perfection is achieved.